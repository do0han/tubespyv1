{
  "master": {
    "tasks": [
      {
        "id": 4,
        "title": "YouTube Data API Integration",
        "description": "Implement integration with YouTube Data API v3 to fetch channel and video data for authenticated users",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "1. Set up YouTube Data API v3 credentials in Google Cloud Console\n2. Install Google API client: `npm install googleapis`\n3. Create YouTube API utility in lib/youtube.ts:\n```typescript\nimport { google } from 'googleapis';\nimport { Session } from 'next-auth';\n\nexport async function getYouTubeClient(session: Session) {\n  const oauth2Client = new google.auth.OAuth2(\n    process.env.GOOGLE_CLIENT_ID,\n    process.env.GOOGLE_CLIENT_SECRET\n  );\n  \n  oauth2Client.setCredentials({\n    access_token: session.accessToken\n  });\n\n  return google.youtube({\n    version: 'v3',\n    auth: oauth2Client\n  });\n}\n\nexport async function getChannels(session: Session) {\n  const youtube = await getYouTubeClient(session);\n  const response = await youtube.channels.list({\n    part: ['snippet,contentDetails,statistics'],\n    mine: true\n  });\n  return response.data.items;\n}\n\nexport async function getChannelVideos(session: Session, channelId: string) {\n  const youtube = await getYouTubeClient(session);\n  \n  // Get uploads playlist ID\n  const channelResponse = await youtube.channels.list({\n    part: ['contentDetails'],\n    id: [channelId]\n  });\n  \n  const uploadsPlaylistId = channelResponse.data.items?.[0].contentDetails?.relatedPlaylists?.uploads;\n  \n  // Get videos from uploads playlist\n  const videosResponse = await youtube.playlistItems.list({\n    part: ['snippet,contentDetails'],\n    playlistId: uploadsPlaylistId,\n    maxResults: 50\n  });\n  \n  // Get video statistics\n  const videoIds = videosResponse.data.items?.map(item => item.contentDetails?.videoId) || [];\n  \n  const videoStatsResponse = await youtube.videos.list({\n    part: ['statistics'],\n    id: videoIds as string[]\n  });\n  \n  // Combine video data\n  return videosResponse.data.items?.map(video => {\n    const stats = videoStatsResponse.data.items?.find(\n      stat => stat.id === video.contentDetails?.videoId\n    );\n    return {\n      ...video,\n      statistics: stats?.statistics\n    };\n  });\n}\n```\n4. Create API endpoints for fetching YouTube data\n5. Implement rate limiting to avoid hitting YouTube API quotas\n6. Add error handling for API requests\n7. Set up data transformation utilities to format API responses",
        "testStrategy": "Test API integration by creating test routes that fetch channel and video data. Verify correct data retrieval by logging responses. Test error handling by simulating API failures. Verify rate limiting functionality works correctly. Create unit tests for data transformation utilities.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Channel Connection UI Flow",
        "description": "Develop the user interface for connecting YouTube channels to the application after authentication",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "medium",
        "details": "This task has been completed as the YouTube search functionality has already been implemented, including:\n\n1. Channel search functionality\n2. Video search functionality\n3. Display of subscriber count data\n4. Search UI with filter panel\n\nThe original requirements have been satisfied through the existing implementation:\n- Channel selection is available through the search functionality\n- Channel data including thumbnails, names, and subscriber counts are displayed\n- The search UI provides the necessary interface for finding and selecting channels\n- The system already handles the connection between users and YouTube channels",
        "testStrategy": "The implemented YouTube search functionality has been tested to verify:\n- Authentication flow works correctly\n- Channels are displayed with proper information (thumbnails, names, subscriber counts)\n- Search filters function as expected\n- Channel selection works properly\n- The UI is responsive across different screen sizes\n- Error states display appropriate messages",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement YouTube channel search",
            "description": "Channel search functionality has been implemented with the ability to display channel thumbnails, names, and subscriber counts.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement video search functionality",
            "description": "Video search has been implemented alongside channel search.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create search UI with filter panel",
            "description": "Search interface with filtering options has been completed.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Data Storage and Synchronization",
        "description": "Implement functionality to store and update YouTube channel and video data in the database",
        "details": "1. Create data synchronization service in lib/sync.ts\n2. Implement functions to save channel data to database:\n```typescript\nimport prisma from './prisma';\nimport { getChannels, getChannelVideos } from './youtube';\nimport { Session } from 'next-auth';\n\nexport async function syncChannelData(session: Session, channelId: string) {\n  const channels = await getChannels(session);\n  const channel = channels?.find(c => c.id === channelId);\n  \n  if (!channel) {\n    throw new Error('Channel not found');\n  }\n  \n  // Update or create channel in database\n  const updatedChannel = await prisma.channel.upsert({\n    where: { youtube_id: channel.id },\n    update: {\n      name: channel.snippet?.title,\n      subscriber_count: parseInt(channel.statistics?.subscriberCount || '0'),\n      view_count: parseInt(channel.statistics?.viewCount || '0')\n    },\n    create: {\n      youtube_id: channel.id,\n      name: channel.snippet?.title,\n      subscriber_count: parseInt(channel.statistics?.subscriberCount || '0'),\n      view_count: parseInt(channel.statistics?.viewCount || '0'),\n      user: {\n        connect: { id: session.user.id }\n      }\n    }\n  });\n  \n  return updatedChannel;\n}\n\nexport async function syncVideoData(session: Session, channelId: string) {\n  const videos = await getChannelVideos(session, channelId);\n  const dbChannel = await prisma.channel.findUnique({\n    where: { youtube_id: channelId }\n  });\n  \n  if (!dbChannel) {\n    throw new Error('Channel not found in database');\n  }\n  \n  // Process videos in batches to avoid overwhelming the database\n  const batchSize = 10;\n  const batches = [];\n  \n  for (let i = 0; i < videos?.length || 0; i += batchSize) {\n    const batch = videos?.slice(i, i + batchSize) || [];\n    batches.push(batch);\n  }\n  \n  const results = [];\n  \n  for (const batch of batches) {\n    const batchResults = await Promise.all(\n      batch.map(async (video) => {\n        return prisma.video.upsert({\n          where: { youtube_id: video.contentDetails?.videoId },\n          update: {\n            title: video.snippet?.title,\n            view_count: parseInt(video.statistics?.viewCount || '0'),\n            like_count: parseInt(video.statistics?.likeCount || '0'),\n            comment_count: parseInt(video.statistics?.commentCount || '0')\n          },\n          create: {\n            youtube_id: video.contentDetails?.videoId,\n            title: video.snippet?.title,\n            published_at: new Date(video.snippet?.publishedAt),\n            view_count: parseInt(video.statistics?.viewCount || '0'),\n            like_count: parseInt(video.statistics?.likeCount || '0'),\n            comment_count: parseInt(video.statistics?.commentCount || '0'),\n            channel: {\n              connect: { id: dbChannel.id }\n            }\n          }\n        });\n      })\n    );\n    \n    results.push(...batchResults);\n  }\n  \n  return results;\n}\n```\n3. Create API endpoints for data synchronization\n4. Implement background refresh mechanism for keeping data up-to-date\n5. Add data validation before storage\n6. Implement error handling and retry logic for failed synchronizations",
        "testStrategy": "Test data storage by syncing a test channel and verifying data is correctly saved to the database. Test data updates by changing channel data and confirming updates are reflected. Test error handling by simulating API failures. Verify data validation correctly handles invalid data. Test performance with larger datasets to ensure efficient processing.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Dashboard Layout and Navigation",
        "description": "Create the main application layout with responsive design and navigation components",
        "status": "pending",
        "dependencies": [
          1,
          3
        ],
        "priority": "medium",
        "details": "1. Create layout components:\n   - app/layout.tsx for global layout\n   - app/dashboard/layout.tsx for authenticated dashboard layout\n2. Implement navigation components:\n   - Header with logo, user profile, and authentication status\n   - Sidebar with navigation links\n   - Mobile-responsive navigation menu\n3. Create dashboard page structure:\n   - Overview page (main dashboard)\n   - Videos page (video analytics)\n   - Channel page (channel details)\n   - Settings page\n4. Implement responsive design using TailwindCSS:\n   - Mobile-first approach\n   - Breakpoints for tablet and desktop\n   - Collapsible sidebar for smaller screens\n5. Add loading states and transitions\n6. Implement protected routes using middleware\n7. Create error boundary components for graceful error handling",
        "testStrategy": "Test layout responsiveness across different screen sizes (mobile, tablet, desktop). Verify navigation components work correctly and links navigate to the right pages. Test protected routes by attempting to access them without authentication. Verify loading states display correctly during navigation. Test error boundaries by simulating component errors.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Channel Analytics Dashboard",
        "description": "Develop the main analytics dashboard displaying channel performance metrics and trends",
        "details": "1. Create dashboard components:\n   - MetricCard for displaying key statistics\n   - ChannelOverview for channel summary\n   - SubscriberChart for subscriber growth visualization\n   - ViewsChart for view count trends\n   - EngagementMetrics for engagement rate display\n2. Implement data fetching for dashboard:\n```typescript\n// app/dashboard/page.tsx\nimport { getServerSession } from 'next-auth';\nimport prisma from '@/lib/prisma';\nimport { MetricCard, ChannelOverview, SubscriberChart, ViewsChart, EngagementMetrics } from '@/components/dashboard';\n\nexport default async function DashboardPage() {\n  const session = await getServerSession();\n  \n  if (!session) {\n    redirect('/auth/signin');\n  }\n  \n  const channels = await prisma.channel.findMany({\n    where: {\n      user: { id: session.user.id }\n    },\n    include: {\n      videos: {\n        orderBy: { published_at: 'desc' },\n        take: 10\n      }\n    }\n  });\n  \n  const channel = channels[0]; // For MVP, we're focusing on a single channel\n  \n  if (!channel) {\n    redirect('/channels/connect');\n  }\n  \n  // Calculate engagement metrics\n  const totalViews = channel.videos.reduce((sum, video) => sum + video.view_count, 0);\n  const totalLikes = channel.videos.reduce((sum, video) => sum + video.like_count, 0);\n  const totalComments = channel.videos.reduce((sum, video) => sum + video.comment_count, 0);\n  const engagementRate = totalViews > 0 ? ((totalLikes + totalComments) / totalViews) * 100 : 0;\n  \n  return (\n    <div className=\"p-4 space-y-6\">\n      <h1 className=\"text-2xl font-bold\">Channel Dashboard</h1>\n      \n      <ChannelOverview channel={channel} />\n      \n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n        <MetricCard title=\"Subscribers\" value={channel.subscriber_count} />\n        <MetricCard title=\"Total Views\" value={channel.view_count} />\n        <MetricCard title=\"Engagement Rate\" value={`${engagementRate.toFixed(2)}%`} />\n      </div>\n      \n      <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n        <SubscriberChart channelId={channel.id} />\n        <ViewsChart channelId={channel.id} />\n      </div>\n      \n      <EngagementMetrics videos={channel.videos} />\n    </div>\n  );\n}\n```\n3. Create chart components using a charting library (e.g., Chart.js or Recharts)\n4. Implement data transformation utilities for chart data\n5. Add time period selectors (7 days, 30 days, etc.)\n6. Create loading and error states for data fetching\n7. Implement data refresh functionality",
        "testStrategy": "Test dashboard rendering with sample data to verify layout and components. Test data fetching by connecting a real YouTube channel and verifying metrics display correctly. Test chart components with different data sets to ensure proper visualization. Verify responsive design across different screen sizes. Test time period selectors to ensure data updates correctly.",
        "priority": "high",
        "dependencies": [
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Video Analytics Implementation",
        "description": "Develop the video analytics section with list and detail views for individual video performance",
        "details": "1. Create video list page in app/dashboard/videos/page.tsx:\n   - Table/grid view of videos with key metrics\n   - Sorting and filtering options\n   - Pagination for large video collections\n2. Implement video detail page in app/dashboard/videos/[id]/page.tsx:\n   - Video metadata display\n   - Performance metrics visualization\n   - Engagement statistics\n3. Create video analytics components:\n   - VideoCard for list view\n   - VideoMetrics for detailed statistics\n   - VideoPerformanceChart for performance visualization\n   - VideoComparison for comparing with channel average\n4. Implement data fetching for video analytics:\n```typescript\n// app/dashboard/videos/page.tsx\nimport { getServerSession } from 'next-auth';\nimport prisma from '@/lib/prisma';\nimport { VideoList, VideoFilters } from '@/components/videos';\n\nexport default async function VideosPage({ searchParams }) {\n  const session = await getServerSession();\n  \n  if (!session) {\n    redirect('/auth/signin');\n  }\n  \n  const { sort = 'published_at', order = 'desc', page = '1' } = searchParams;\n  const pageSize = 10;\n  const pageNumber = parseInt(page);\n  \n  const channels = await prisma.channel.findMany({\n    where: {\n      user: { id: session.user.id }\n    },\n    take: 1\n  });\n  \n  const channel = channels[0];\n  \n  if (!channel) {\n    redirect('/channels/connect');\n  }\n  \n  const videos = await prisma.video.findMany({\n    where: {\n      channel_id: channel.id\n    },\n    orderBy: {\n      [sort]: order\n    },\n    skip: (pageNumber - 1) * pageSize,\n    take: pageSize\n  });\n  \n  const totalVideos = await prisma.video.count({\n    where: {\n      channel_id: channel.id\n    }\n  });\n  \n  const totalPages = Math.ceil(totalVideos / pageSize);\n  \n  return (\n    <div className=\"p-4 space-y-6\">\n      <h1 className=\"text-2xl font-bold\">Video Analytics</h1>\n      \n      <VideoFilters currentSort={sort} currentOrder={order} />\n      \n      <VideoList videos={videos} />\n      \n      <Pagination currentPage={pageNumber} totalPages={totalPages} />\n    </div>\n  );\n}\n```\n5. Create video detail page with performance metrics\n6. Implement video comparison functionality\n7. Add data export options (CSV)",
        "testStrategy": "Test video list page with sample data to verify sorting, filtering, and pagination. Test video detail page to ensure metrics display correctly. Verify responsive design for both list and detail views. Test data fetching with real YouTube data. Test video comparison functionality with different videos. Verify data export generates correct CSV files.",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Chart and Data Visualization Components",
        "description": "Implement reusable chart components for visualizing analytics data throughout the application",
        "details": "1. Set up a charting library (Recharts recommended for React):\n   `npm install recharts`\n2. Create base chart components:\n   - LineChart for trend visualization\n   - BarChart for comparison data\n   - PieChart for distribution data\n   - AreaChart for cumulative metrics\n3. Implement chart wrapper components with loading and error states\n4. Create data transformation utilities for chart data:\n```typescript\n// lib/chartUtils.ts\nexport function prepareTimeSeriesData(data, valueKey, dateKey) {\n  // Sort data by date\n  const sortedData = [...data].sort((a, b) => {\n    return new Date(a[dateKey]) - new Date(b[dateKey]);\n  });\n  \n  // Format data for charts\n  return sortedData.map(item => ({\n    date: new Date(item[dateKey]).toLocaleDateString(),\n    value: item[valueKey]\n  }));\n}\n\nexport function calculateGrowthRate(current, previous) {\n  if (previous === 0) return 100;\n  return ((current - previous) / previous) * 100;\n}\n\nexport function aggregateDataByPeriod(data, valueKey, dateKey, period = 'day') {\n  const aggregated = {};\n  \n  data.forEach(item => {\n    const date = new Date(item[dateKey]);\n    let periodKey;\n    \n    switch (period) {\n      case 'day':\n        periodKey = date.toISOString().split('T')[0];\n        break;\n      case 'week':\n        const weekStart = new Date(date);\n        weekStart.setDate(date.getDate() - date.getDay());\n        periodKey = weekStart.toISOString().split('T')[0];\n        break;\n      case 'month':\n        periodKey = `${date.getFullYear()}-${date.getMonth() + 1}`;\n        break;\n      default:\n        periodKey = date.toISOString().split('T')[0];\n    }\n    \n    if (!aggregated[periodKey]) {\n      aggregated[periodKey] = 0;\n    }\n    \n    aggregated[periodKey] += item[valueKey];\n  });\n  \n  return Object.entries(aggregated).map(([date, value]) => ({\n    date,\n    value\n  }));\n}\n```\n5. Implement responsive chart designs for different screen sizes\n6. Create chart theme consistent with application design\n7. Add interactive features (tooltips, zoom, etc.)\n8. Implement chart export functionality (PNG/SVG)",
        "testStrategy": "Test chart components with various data sets to ensure proper rendering. Verify responsive behavior across different screen sizes. Test data transformation utilities with different input formats. Test interactive features like tooltips and zooming. Verify chart export functionality generates correct files. Test edge cases like empty data sets and extreme values.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Error Handling and User Feedback",
        "description": "Implement comprehensive error handling and user feedback mechanisms throughout the application",
        "details": "1. Create error boundary components:\n```typescript\n// components/ErrorBoundary.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\n\nexport default function ErrorBoundary({ children }) {\n  const [hasError, setHasError] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    const errorHandler = (error: ErrorEvent) => {\n      setHasError(true);\n      setError(error.error);\n      // Optionally log to an error tracking service\n    };\n\n    window.addEventListener('error', errorHandler);\n    return () => window.removeEventListener('error', errorHandler);\n  }, []);\n\n  if (hasError) {\n    return (\n      <div className=\"p-4 rounded-md bg-red-50 border border-red-200\">\n        <h2 className=\"text-lg font-semibold text-red-800\">Something went wrong</h2>\n        <p className=\"text-red-600\">{error?.message || 'An unexpected error occurred'}</p>\n        <button \n          className=\"mt-2 px-3 py-1 bg-red-100 text-red-800 rounded-md hover:bg-red-200\"\n          onClick={() => setHasError(false)}\n        >\n          Try again\n        </button>\n      </div>\n    );\n  }\n\n  return children;\n}\n```\n2. Implement toast notifications for user feedback:\n   - Install a toast library: `npm install react-hot-toast`\n   - Create toast wrapper for consistent styling\n3. Create loading states and skeletons for data fetching\n4. Implement form validation with error messages\n5. Create API error handling utilities:\n```typescript\n// lib/apiUtils.ts\nexport async function fetchWithErrorHandling(url, options = {}) {\n  try {\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new Error(errorData.message || `API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    // Log error or send to monitoring service\n    console.error('API request failed:', error);\n    throw error;\n  }\n}\n\nexport function handleApiError(error, fallbackMessage = 'An error occurred') {\n  // Extract meaningful error message\n  const errorMessage = error.message || fallbackMessage;\n  \n  // Show user-friendly toast\n  toast.error(errorMessage);\n  \n  // Optionally log to error tracking service\n  \n  return { error: errorMessage };\n}\n```\n6. Add empty states for no data scenarios\n7. Implement retry mechanisms for failed operations",
        "testStrategy": "Test error boundary by intentionally causing component errors. Verify toast notifications display correctly for different scenarios. Test loading states by simulating slow network responses. Verify form validation correctly identifies and displays errors. Test API error handling with mocked failed responses. Verify empty states display correctly when no data is available.",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Deployment to Vercel",
        "description": "Configure and deploy the MVP application to Vercel for production use",
        "details": "1. Create a Vercel account if not already available\n2. Install Vercel CLI: `npm install -g vercel`\n3. Configure Vercel project settings:\n   - Create vercel.json configuration file\n   - Set up environment variables in Vercel dashboard\n   - Configure build settings\n4. Set up database connection for production:\n   - Create production database in Supabase\n   - Configure database connection string in Vercel\n5. Configure domain settings (if applicable)\n6. Set up continuous deployment from GitHub repository\n7. Implement pre-deployment checks:\n   - Linting: `npm run lint`\n   - Type checking: `npm run type-check`\n   - Build verification: `npm run build`\n8. Deploy the application: `vercel --prod`\n9. Verify deployment and test in production environment\n10. Set up monitoring and error tracking",
        "testStrategy": "Test deployment by pushing changes to the repository and verifying automatic deployment. Verify environment variables are correctly set in production. Test the application in production environment to ensure all features work correctly. Verify database connections work in production. Test performance metrics like page load times. Verify error tracking is working correctly by simulating errors.",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 1,
        "title": "Setup Next.js 14 Project with TypeScript, TailwindCSS, and Shadcn/ui",
        "description": "TubeSpy MVPì˜ ê¸°ë°˜ì„ êµ¬ì¶•í•˜ê¸° ìœ„í•´ Next.js 14, TypeScript, TailwindCSS, Shadcn/ui ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ í”„ë¡œì íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Create a new Next.js 14 project with App Router:\n   ```bash\n   npx create-next-app@latest tubespy --typescript --tailwind --eslint --app\n   ```\n\n2. Configure TypeScript settings in tsconfig.json:\n   - Ensure strict mode is enabled\n   - Configure path aliases for cleaner imports\n   - Set appropriate target and lib options\n\n3. Set up TailwindCSS configuration:\n   - Customize theme in tailwind.config.js\n   - Define color palette, typography, and spacing\n   - Configure plugins as needed\n\n4. Install and configure Shadcn/ui:\n   ```bash\n   npx shadcn-ui@latest init\n   ```\n   - Select appropriate styling options (default: tailwindcss)\n   - Configure component directory structure\n   - Set up color themes (light/dark mode)\n\n5. Create basic folder structure:\n   - app/ (for App Router)\n   - components/ (for UI components)\n   - lib/ (for utility functions)\n   - types/ (for TypeScript types)\n   - styles/ (for global styles)\n\n6. Set up environment variables:\n   - Create .env.local file\n   - Add .env.example for documentation\n   - Configure environment variable types\n\n7. Install additional core dependencies:\n   ```bash\n   npm install clsx tailwind-merge lucide-react\n   ```\n\n8. Configure ESLint and Prettier:\n   - Set up consistent code formatting rules\n   - Configure TypeScript-specific linting rules\n\n9. Create basic UI components using Shadcn/ui:\n   ```bash\n   npx shadcn-ui@latest add button card dialog input\n   ```\n\n10. Set up a basic landing page in app/page.tsx to verify the setup works correctly.\n<info added on 2025-06-25T05:13:48.080Z>\n## Task #1 ì™„ë£Œ ìƒíƒœ\n\nâœ… ì™„ë£Œëœ ì‘ì—…ë“¤:\n1. Next.js 14 í”„ë¡œì íŠ¸ ìƒì„± (app ë””ë ‰í† ë¦¬ì—)\n   - TypeScript, TailwindCSS, ESLint, App Router ëª¨ë‘ ì„¤ì •ë¨\n   - src ë””ë ‰í† ë¦¬ êµ¬ì¡°ë¡œ ì •ë¦¬\n\n2. Shadcn/ui ì„¤ì¹˜ ë° ì„¤ì • ì™„ë£Œ\n   - ê¸°ë³¸ ì»´í¬ë„ŒíŠ¸ë“¤ ì„¤ì¹˜: button, card, dialog, input, badge, avatar, dropdown-menu\n   - ì»´í¬ë„ŒíŠ¸ ì„¤ì • íŒŒì¼ ìƒì„±ë¨\n\n3. ì¶”ê°€ íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì™„ë£Œ\n   - clsx, tailwind-merge, lucide-react, @radix-ui/react-icons\n\n4. TubeSpy ëœë”© í˜ì´ì§€ êµ¬í˜„\n   - í•œêµ­ì–´ UIë¡œ ë¸Œëœë”©\n   - Shadcn/ui ì»´í¬ë„ŒíŠ¸ë“¤ì„ í™œìš©í•œ ëª¨ë˜í•œ ë””ìì¸\n   - ë°˜ì‘í˜• ë ˆì´ì•„ì›ƒ\n   - ë‹¤í¬ëª¨ë“œ ì§€ì›\n\n5. ëª¨ë“  í…ŒìŠ¤íŠ¸ ì„±ê³µ\n   - ë¹Œë“œ í…ŒìŠ¤íŠ¸: âœ… ì„±ê³µ (3.0ì´ˆ, ìµœì í™”ë¨)\n   - ë¦°íŠ¸ í…ŒìŠ¤íŠ¸: âœ… ê²½ê³ /ì—ëŸ¬ ì—†ìŒ\n   - ê°œë°œ ì„œë²„: âœ… ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ ì¤‘\n\nğŸ¯ ë‹¤ìŒ ë‹¨ê³„: Task #2 (ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„)ë¡œ ì§„í–‰ ê°€ëŠ¥\n</info added on 2025-06-25T05:13:48.080Z>",
        "testStrategy": "1. Verify project structure by checking that all directories and configuration files are correctly created:\n   - Confirm app/ directory exists with proper Next.js 14 structure\n   - Verify tsconfig.json has correct settings\n   - Check tailwind.config.js for proper configuration\n\n2. Run the development server with `npm run dev` and confirm the application loads without errors:\n   - Check browser console for any errors or warnings\n   - Verify the application renders correctly at http://localhost:3000\n\n3. Test TypeScript configuration:\n   - Create a test component with TypeScript types\n   - Verify type checking works as expected\n   - Test path aliases to ensure they resolve correctly\n\n4. Test TailwindCSS functionality:\n   - Create a component using Tailwind classes\n   - Verify styles are applied correctly\n   - Test responsive design with different viewport sizes\n\n5. Test Shadcn/ui components:\n   - Render basic components (Button, Card, Dialog)\n   - Verify they display correctly with proper styling\n   - Test component interactions (click events, state changes)\n\n6. Verify dark mode functionality:\n   - Test theme switching between light and dark modes\n   - Ensure components respond correctly to theme changes\n\n7. Run ESLint to verify code quality:\n   ```bash\n   npm run lint\n   ```\n   - Ensure no linting errors are present\n\n8. Test build process to ensure production readiness:\n   ```bash\n   npm run build\n   ```\n   - Verify build completes without errors\n   - Check build output for optimization",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Design and Implement Simplified Database Schema with Prisma for MVP",
        "description": "Create and implement a simplified database schema using Prisma ORM for the MVP, focusing only on User, Channel, and Video models with their essential relationships.",
        "details": "1. Analyze the MVP requirements to determine essential fields for each model:\n\n**User Model**:\n- Basic user information (id, name, email)\n- Authentication details (OAuth identifiers)\n- Timestamps for user creation and updates\n\n**Channel Model**:\n- Channel identifiers (id, YouTube channel ID)\n- Basic channel metadata (title, description, thumbnail URL)\n- Performance metrics (subscriber count, view count)\n- Relationship to User model\n- Timestamps for data creation and updates\n\n**Video Model**:\n- Video identifiers (id, YouTube video ID)\n- Basic video metadata (title, description, thumbnail URL)\n- Performance metrics (view count, like count, comment count)\n- Relationship to Channel model\n- Timestamps for data creation and updates\n\n2. Create the Prisma schema in `prisma/schema.prisma`:\n```prisma\n// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id            String    @id @default(cuid())\n  name          String?\n  email         String    @unique\n  image         String?\n  googleId      String?   @unique\n  createdAt     DateTime  @default(now()) @map(\"created_at\")\n  updatedAt     DateTime  @updatedAt @map(\"updated_at\")\n  channels      Channel[]\n\n  @@map(\"users\")\n}\n\nmodel Channel {\n  id              String    @id @default(cuid())\n  youtubeId       String    @unique @map(\"youtube_id\")\n  title           String\n  description     String?\n  thumbnailUrl    String?   @map(\"thumbnail_url\")\n  subscriberCount Int?      @map(\"subscriber_count\")\n  viewCount       Int?      @map(\"view_count\")\n  videoCount      Int?      @map(\"video_count\")\n  createdAt       DateTime  @default(now()) @map(\"created_at\")\n  updatedAt       DateTime  @updatedAt @map(\"updated_at\")\n  userId          String    @map(\"user_id\")\n  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  videos          Video[]\n\n  @@map(\"channels\")\n}\n\nmodel Video {\n  id              String    @id @default(cuid())\n  youtubeId       String    @unique @map(\"youtube_id\")\n  title           String\n  description     String?\n  thumbnailUrl    String?   @map(\"thumbnail_url\")\n  publishedAt     DateTime? @map(\"published_at\")\n  viewCount       Int?      @map(\"view_count\")\n  likeCount       Int?      @map(\"like_count\")\n  commentCount    Int?      @map(\"comment_count\")\n  duration        String?\n  createdAt       DateTime  @default(now()) @map(\"created_at\")\n  updatedAt       DateTime  @updatedAt @map(\"updated_at\")\n  channelId       String    @map(\"channel_id\")\n  channel         Channel   @relation(fields: [channelId], references: [id], onDelete: Cascade)\n\n  @@map(\"videos\")\n}\n```\n\n3. Create a Prisma client instance in `lib/prisma.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma = globalForPrisma.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n\nexport default prisma;\n```\n\n4. Generate Prisma client:\n```bash\nnpx prisma generate\n```\n\n5. Create initial migration:\n```bash\nnpx prisma migrate dev --name init\n```\n\n6. Create database seed script (optional) in `prisma/seed.ts`:\n```typescript\nimport { PrismaClient } from '@prisma/client';\nconst prisma = new PrismaClient();\n\nasync function main() {\n  // Create test user\n  const user = await prisma.user.upsert({\n    where: { email: 'test@example.com' },\n    update: {},\n    create: {\n      email: 'test@example.com',\n      name: 'Test User',\n      googleId: 'test123',\n    },\n  });\n\n  // Create test channel\n  const channel = await prisma.channel.upsert({\n    where: { youtubeId: 'UC_test_channel' },\n    update: {},\n    create: {\n      youtubeId: 'UC_test_channel',\n      title: 'Test Channel',\n      description: 'A test YouTube channel',\n      thumbnailUrl: 'https://example.com/thumbnail.jpg',\n      subscriberCount: 1000,\n      viewCount: 50000,\n      videoCount: 25,\n      userId: user.id,\n    },\n  });\n\n  // Create test video\n  await prisma.video.upsert({\n    where: { youtubeId: 'test_video_id' },\n    update: {},\n    create: {\n      youtubeId: 'test_video_id',\n      title: 'Test Video',\n      description: 'A test YouTube video',\n      thumbnailUrl: 'https://example.com/video-thumbnail.jpg',\n      publishedAt: new Date(),\n      viewCount: 1500,\n      likeCount: 100,\n      commentCount: 25,\n      duration: 'PT10M30S',\n      channelId: channel.id,\n    },\n  });\n\n  console.log('Database seeded successfully');\n}\n\nmain()\n  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n```\n\n7. Update package.json to include seed script:\n```json\n\"prisma\": {\n  \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"\n}\n```\n\n8. Document the schema design decisions and relationships for the development team.\n<info added on 2025-06-25T05:20:03.639Z>\n9. Implementation completed:\n   - Successfully installed and initialized Prisma ORM with required packages\n   - Created and configured the database schema as specified in the task\n\n10. Extended the schema with additional models for NextAuth.js support:\n    - Added Account, Session, and VerificationToken models to support authentication\n\n11. Developed database service utilities:\n    - userService: Functions for user creation and retrieval\n    - channelService: Functions for channel upsert and retrieval operations\n    - videoService: Functions for video upsert and retrieval operations\n    - statsService: Functions for statistics and trend analysis\n\n12. Created comprehensive TypeScript type definitions:\n    - Re-exported base model types\n    - Defined extended types (WithChannels, WithVideos, etc.)\n    - Added YouTube API response types\n    - Defined API request/response types\n\n13. Verified implementation with successful tests:\n    - Build test passed with optimal performance\n    - Lint test passed with no warnings or errors\n    - TypeScript compilation completed successfully\n\n14. Ready for next phase: Task #3 (NextAuth.js Google OAuth authentication)\n</info added on 2025-06-25T05:20:03.639Z>",
        "testStrategy": "1. Verify schema integrity:\n   - Run `npx prisma validate` to ensure the schema is valid\n   - Check for any warnings or errors in the schema definition\n\n2. Test database migrations:\n   - Run `npx prisma migrate dev` to apply migrations to development database\n   - Verify that all tables are created with correct columns and relationships\n   - Check constraints and indexes are properly applied\n\n3. Test Prisma client generation:\n   - Run `npx prisma generate` to create the Prisma client\n   - Verify that TypeScript types are correctly generated\n   - Import the client in a test file to check for any import errors\n\n4. Test basic CRUD operations:\n   - Create a test script that performs Create, Read, Update, and Delete operations on each model\n   - Verify relationships work correctly (e.g., creating a video associated with a channel)\n   - Test cascade deletions (e.g., deleting a user should delete associated channels)\n\n5. Test data validation:\n   - Attempt to create records with invalid data to ensure constraints are enforced\n   - Test unique constraints on email and YouTube IDs\n   - Verify required fields cannot be null\n\n6. Run database seed script:\n   - Execute `npx prisma db seed` to populate test data\n   - Verify all test records are created with correct relationships\n\n7. Test integration with NextAuth:\n   - Verify the User model works correctly with NextAuth.js adapter\n   - Test user creation during OAuth authentication flow\n\n8. Test integration with YouTube API data:\n   - Create a test script that fetches sample YouTube data and stores it using the schema\n   - Verify all relevant fields from the API can be mapped to the database schema",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement NextAuth.js Authentication with Google OAuth for YouTube Channel Access",
        "description": "Set up NextAuth.js with Google OAuth provider, configuring the necessary scopes for YouTube Data API access to allow users to authenticate and access their YouTube channel data.",
        "details": "1. Install required packages:\n```bash\nnpm install next-auth@latest @auth/prisma-adapter\n```\n\n2. Configure environment variables in `.env.local`:\n```\nNEXTAUTH_URL=http://localhost:3000\nNEXTAUTH_SECRET=your_generated_secret_here\nGOOGLE_CLIENT_ID=your_google_client_id\nGOOGLE_CLIENT_SECRET=your_google_client_secret\n```\n\n3. Create NextAuth API route in `app/api/auth/[...nextauth]/route.ts`:\n```typescript\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\nimport { PrismaAdapter } from '@auth/prisma-adapter';\nimport prisma from '@/lib/prisma';\n\nexport const authOptions = {\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      authorization: {\n        params: {\n          scope: 'openid email profile https://www.googleapis.com/auth/youtube.readonly',\n          prompt: 'consent',\n          access_type: 'offline',\n        },\n      },\n    }),\n  ],\n  callbacks: {\n    async session({ session, user, token }) {\n      // Add user ID to session\n      if (session.user) {\n        session.user.id = user.id;\n      }\n      \n      // Add access token to session for YouTube API calls\n      if (token?.accessToken) {\n        session.accessToken = token.accessToken;\n      }\n      \n      return session;\n    },\n    async jwt({ token, account }) {\n      // Persist the OAuth access_token to the token right after sign in\n      if (account) {\n        token.accessToken = account.access_token;\n        token.refreshToken = account.refresh_token;\n        token.expiresAt = account.expires_at;\n      }\n      return token;\n    },\n  },\n  pages: {\n    signIn: '/login',\n    error: '/login',\n  },\n  session: {\n    strategy: 'jwt',\n  },\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\n\n4. Create a session provider in `app/providers.tsx`:\n```typescript\n'use client';\n\nimport { SessionProvider } from 'next-auth/react';\n\nexport function Providers({ children }) {\n  return <SessionProvider>{children}</SessionProvider>;\n}\n```\n\n5. Add the provider to the root layout in `app/layout.tsx`:\n```typescript\nimport { Providers } from './providers';\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  );\n}\n```\n\n6. Create login page in `app/login/page.tsx`:\n```typescript\n'use client';\n\nimport { signIn } from 'next-auth/react';\nimport { Button } from '@/components/ui/button';\n\nexport default function LoginPage() {\n  return (\n    <div className=\"flex min-h-screen items-center justify-center\">\n      <div className=\"w-full max-w-md space-y-8 p-10 rounded-xl shadow-lg\">\n        <div className=\"text-center\">\n          <h1 className=\"text-3xl font-bold\">Welcome to TubeSpy</h1>\n          <p className=\"mt-2 text-gray-600\">Sign in to access your YouTube analytics</p>\n        </div>\n        <Button \n          className=\"w-full\" \n          onClick={() => signIn('google', { callbackUrl: '/dashboard' })}\n        >\n          Sign in with Google\n        </Button>\n      </div>\n    </div>\n  );\n}\n```\n\n7. Create a utility to check authentication in `lib/auth.ts`:\n```typescript\nimport { getServerSession } from 'next-auth';\nimport { redirect } from 'next/navigation';\nimport { authOptions } from '@/app/api/auth/[...nextauth]/route';\n\nexport async function getSession() {\n  return await getServerSession(authOptions);\n}\n\nexport async function requireAuth() {\n  const session = await getSession();\n  \n  if (!session) {\n    redirect('/login');\n  }\n  \n  return session;\n}\n```\n\n8. Update TypeScript types for NextAuth in `types/next-auth.d.ts`:\n```typescript\nimport NextAuth from 'next-auth';\n\ndeclare module 'next-auth' {\n  interface Session {\n    user: {\n      id: string;\n      name: string;\n      email: string;\n      image?: string;\n    };\n    accessToken?: string;\n  }\n}\n```\n\n9. Create a protected route example in `app/dashboard/page.tsx`:\n```typescript\nimport { requireAuth } from '@/lib/auth';\n\nexport default async function DashboardPage() {\n  const session = await requireAuth();\n  \n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <p>Welcome, {session.user.name}</p>\n    </div>\n  );\n}\n```\n<info added on 2025-06-25T05:31:42.285Z>\n## Implementation Status\n\nâœ… **Completed Tasks:**\n1. NextAuth.js and @auth/prisma-adapter packages installed\n2. NextAuth API route created (/src/app/api/auth/[...nextauth]/route.ts)\n   - Google OAuth provider configured\n   - YouTube read permission scope included\n   - Prisma adapter connected\n   - JWT session strategy implemented\n\n3. Type definitions and providers set up\n   - NextAuth types extended (/src/types/next-auth.d.ts)\n   - Session Provider component (/src/app/providers.tsx)\n   - Root layout updated\n\n4. Login page created (/src/app/login/page.tsx)\n   - Korean UI, Google OAuth button\n   - Loading state and automatic redirect\n\n5. Dashboard page created (/src/app/dashboard/page.tsx)\n   - Authentication protection, user information display\n   - Channel analysis starting interface\n\n6. Authentication utility functions (/src/lib/auth.ts)\n   - getSession(), requireAuth() functions\n\nâš ï¸ **Next Steps Required:**\n1. Create .env.local file and set up Google OAuth credentials\n2. Generate OAuth 2.0 client ID in Google Cloud Console\n3. Configure database connection\n\nNote: Basic authentication structure is complete, though some TypeScript errors remain.\n</info added on 2025-06-25T05:31:42.285Z>",
        "testStrategy": "1. Test the authentication flow:\n   - Verify the login page renders correctly\n   - Test the Google sign-in button functionality\n   - Confirm successful redirection after authentication\n   - Verify failed authentication scenarios display appropriate error messages\n\n2. Test OAuth scopes and permissions:\n   - Confirm the consent screen shows YouTube access permissions\n   - Verify the application requests the correct scopes\n   - Test that access tokens are properly stored in the session\n\n3. Test session management:\n   - Verify session persistence across page refreshes\n   - Test session expiration and token refresh functionality\n   - Confirm user information is correctly stored in the session\n\n4. Test protected routes:\n   - Verify unauthenticated users are redirected to login\n   - Confirm authenticated users can access protected routes\n   - Test that user-specific data is properly displayed\n\n5. Test database integration:\n   - Verify user data is correctly stored in the database after authentication\n   - Test that existing users can sign in without creating duplicate records\n   - Confirm user relationships with other models work correctly\n\n6. Test error handling:\n   - Simulate authentication failures and verify error handling\n   - Test invalid or expired tokens scenarios\n   - Verify proper error messages are displayed to users\n\n7. Create integration tests:\n   - Write tests that simulate the complete authentication flow\n   - Test the integration between NextAuth and the YouTube Data API\n   - Verify that authenticated users can access their YouTube channel data",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Infinite Scroll for YouTube Search Results",
        "description": "Add infinite scroll or pagination functionality to YouTube search results to allow users to view more search results as they scroll down the page.",
        "details": "1. Evaluate and choose between infinite scroll or pagination approach:\n   - Infinite scroll: Automatically loads more content as user scrolls\n   - Pagination: Displays numbered pages for navigation\n\n2. For infinite scroll implementation:\n   - Install necessary packages: `npm install react-intersection-observer`\n   - Create a custom hook for infinite scrolling:\n```typescript\n// hooks/useInfiniteScroll.ts\nimport { useState, useEffect } from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nexport function useInfiniteScroll(fetchMore: () => Promise<any>, hasMore: boolean) {\n  const [loading, setLoading] = useState(false);\n  const { ref, inView } = useInView({\n    threshold: 0.1,\n  });\n\n  useEffect(() => {\n    if (inView && hasMore && !loading) {\n      setLoading(true);\n      fetchMore().finally(() => setLoading(false));\n    }\n  }, [inView, hasMore, loading, fetchMore]);\n\n  return { ref, loading };\n}\n```\n\n3. Modify the YouTube search API function to support pagination:\n```typescript\n// lib/youtube.ts\nexport async function searchYouTube(\n  session: Session, \n  query: string, \n  pageToken?: string\n) {\n  const youtube = await getYouTubeClient(session);\n  \n  const response = await youtube.search.list({\n    part: ['snippet'],\n    q: query,\n    maxResults: 20,\n    pageToken: pageToken || undefined,\n    type: ['video', 'channel']\n  });\n  \n  return {\n    items: response.data.items || [],\n    nextPageToken: response.data.nextPageToken,\n    prevPageToken: response.data.prevPageToken,\n    totalResults: response.data.pageInfo?.totalResults || 0\n  };\n}\n```\n\n4. Update the search results component to implement infinite scroll:\n```typescript\n// components/SearchResults.tsx\n'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useInfiniteScroll } from '@/hooks/useInfiniteScroll';\nimport { searchYouTube } from '@/lib/youtube';\nimport { useSession } from 'next-auth/react';\nimport VideoCard from './VideoCard';\nimport LoadingSpinner from './LoadingSpinner';\n\nexport default function SearchResults({ initialResults, initialQuery }) {\n  const { data: session } = useSession();\n  const [results, setResults] = useState(initialResults.items || []);\n  const [nextPageToken, setNextPageToken] = useState(initialResults.nextPageToken);\n  const [query, setQuery] = useState(initialQuery);\n  \n  const fetchMoreResults = useCallback(async () => {\n    if (!session || !nextPageToken) return;\n    \n    const moreResults = await searchYouTube(session, query, nextPageToken);\n    setResults(prev => [...prev, ...moreResults.items]);\n    setNextPageToken(moreResults.nextPageToken);\n  }, [session, nextPageToken, query]);\n  \n  const { ref, loading } = useInfiniteScroll(\n    fetchMoreResults,\n    Boolean(nextPageToken)\n  );\n  \n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n      {results.map((item, index) => (\n        <VideoCard key={item.id.videoId || item.id.channelId || index} item={item} />\n      ))}\n      \n      {nextPageToken && (\n        <div ref={ref} className=\"col-span-full flex justify-center p-4\">\n          {loading ? <LoadingSpinner /> : <p>Scroll for more results</p>}\n        </div>\n      )}\n      \n      {!nextPageToken && results.length > 0 && (\n        <div className=\"col-span-full text-center p-4\">\n          <p>No more results</p>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n5. Update the search page to pass initial results:\n```typescript\n// app/search/page.tsx\nimport { getServerSession } from 'next-auth/next';\nimport { searchYouTube } from '@/lib/youtube';\nimport SearchResults from '@/components/SearchResults';\nimport SearchForm from '@/components/SearchForm';\n\nexport default async function SearchPage({ searchParams }) {\n  const session = await getServerSession();\n  const query = searchParams.q || '';\n  \n  let initialResults = { items: [], nextPageToken: null };\n  if (query && session) {\n    initialResults = await searchYouTube(session, query);\n  }\n  \n  return (\n    <div className=\"container mx-auto py-8\">\n      <SearchForm initialQuery={query} />\n      <SearchResults initialResults={initialResults} initialQuery={query} />\n    </div>\n  );\n}\n```\n\n6. Add loading states and error handling:\n   - Display loading indicators during initial load and pagination\n   - Handle API errors gracefully\n   - Provide user feedback when no more results are available\n\n7. Optimize performance:\n   - Implement debouncing for scroll events\n   - Use virtualization for large result sets if needed\n   - Consider caching results to reduce API calls",
        "testStrategy": "1. Test infinite scroll functionality:\n   - Verify that additional results load automatically when scrolling to the bottom of the page\n   - Confirm loading indicators appear during data fetching\n   - Ensure \"No more results\" message displays when all results are loaded\n\n2. Test API integration:\n   - Verify correct handling of pageToken parameter in API requests\n   - Test with various search queries to ensure consistent behavior\n   - Confirm proper error handling when API limits are reached or errors occur\n\n3. Test user experience:\n   - Verify smooth scrolling without performance issues\n   - Test on different devices and screen sizes to ensure responsive behavior\n   - Confirm that the UI remains responsive during data loading\n\n4. Test edge cases:\n   - Empty search results\n   - Very large result sets\n   - Network interruptions during loading\n   - API rate limiting scenarios\n\n5. Performance testing:\n   - Measure and optimize load times for initial and subsequent result pages\n   - Monitor memory usage during extended scrolling sessions\n   - Test with throttled network connections to simulate mobile usage\n\n6. Accessibility testing:\n   - Verify keyboard navigation works with infinite scroll\n   - Ensure screen readers can properly announce new content\n   - Test focus management when new content is loaded\n\n7. Integration testing:\n   - Verify search functionality works end-to-end with the YouTube API\n   - Test that results display correctly with various content types (videos, channels)\n   - Confirm that all UI components update properly when new data is loaded",
        "status": "pending",
        "dependencies": [
          4,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Caching System for YouTube API Requests",
        "description": "Implement a memory caching system with 5-minute TTL for YouTube API requests to reduce API calls and improve application performance.",
        "details": "1. Create a caching utility in `lib/cache.ts`:\n```typescript\n// lib/cache.ts\ntype CacheEntry<T> = {\n  data: T;\n  timestamp: number;\n};\n\nclass MemoryCache {\n  private cache: Map<string, CacheEntry<any>> = new Map();\n  private ttl: number; // Time to live in milliseconds\n\n  constructor(ttlMinutes: number = 5) {\n    this.ttl = ttlMinutes * 60 * 1000;\n  }\n\n  get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    const now = Date.now();\n    if (now - entry.timestamp > this.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data;\n  }\n\n  set<T>(key: string, data: T): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  invalidate(key: string): void {\n    this.cache.delete(key);\n  }\n\n  invalidateAll(): void {\n    this.cache.clear();\n  }\n}\n\n// Create a singleton instance\nconst apiCache = new MemoryCache();\nexport default apiCache;\n```\n\n2. Modify YouTube API utility functions to use the cache:\n```typescript\n// lib/youtube.ts\nimport apiCache from './cache';\nimport { google } from 'googleapis';\nimport { Session } from 'next-auth';\n\nexport async function getYouTubeClient(session: Session) {\n  // Existing implementation\n}\n\nexport async function getChannels(session: Session) {\n  const cacheKey = `channels:${session.user.id}`;\n  const cachedData = apiCache.get(cacheKey);\n  \n  if (cachedData) {\n    return cachedData;\n  }\n  \n  const youtube = await getYouTubeClient(session);\n  const response = await youtube.channels.list({\n    part: ['snippet', 'statistics', 'contentDetails'],\n    mine: true\n  });\n  \n  apiCache.set(cacheKey, response.data.items);\n  return response.data.items;\n}\n\nexport async function searchVideos(session: Session, query: string, pageToken?: string) {\n  const cacheKey = `search:${session.user.id}:${query}:${pageToken || 'initial'}`;\n  const cachedData = apiCache.get(cacheKey);\n  \n  if (cachedData) {\n    return cachedData;\n  }\n  \n  const youtube = await getYouTubeClient(session);\n  const response = await youtube.search.list({\n    part: ['snippet'],\n    q: query,\n    type: ['video'],\n    maxResults: 10,\n    pageToken: pageToken\n  });\n  \n  apiCache.set(cacheKey, response.data);\n  return response.data;\n}\n```\n\n3. Implement cache invalidation for data that changes:\n```typescript\n// Example in a data update function\nexport async function updateVideoData(session: Session, videoId: string, data: any) {\n  // Update the data\n  const youtube = await getYouTubeClient(session);\n  await youtube.videos.update({\n    // update parameters\n  });\n  \n  // Invalidate related cache entries\n  apiCache.invalidate(`video:${session.user.id}:${videoId}`);\n  apiCache.invalidate(`search:${session.user.id}:${data.title}`);\n}\n```\n\n4. Add cache debugging utilities (optional):\n```typescript\n// lib/cache.ts (additional methods)\nclass MemoryCache {\n  // ... existing implementation\n\n  getStats(): { size: number, keys: string[] } {\n    return {\n      size: this.cache.size,\n      keys: Array.from(this.cache.keys())\n    };\n  }\n  \n  getCacheHitRate(): number {\n    return this._hits / (this._hits + this._misses);\n  }\n}\n```\n\n5. Update the infinite scroll implementation to work with cached data:\n```typescript\n// hooks/useYouTubeSearch.ts\nimport { useState, useEffect } from 'react';\nimport { searchVideos } from '../lib/youtube';\nimport { useSession } from 'next-auth/react';\n\nexport function useYouTubeSearch(query: string) {\n  const { data: session } = useSession();\n  const [results, setResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [nextPageToken, setNextPageToken] = useState('');\n  const [hasMore, setHasMore] = useState(true);\n\n  const fetchResults = async (pageToken?: string) => {\n    if (!session || !query) return;\n    \n    setLoading(true);\n    try {\n      const data = await searchVideos(session, query, pageToken);\n      \n      if (pageToken) {\n        setResults(prev => [...prev, ...data.items]);\n      } else {\n        setResults(data.items);\n      }\n      \n      setNextPageToken(data.nextPageToken || '');\n      setHasMore(!!data.nextPageToken);\n    } catch (err) {\n      setError(err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadMore = () => {\n    if (loading || !hasMore) return;\n    fetchResults(nextPageToken);\n  };\n\n  useEffect(() => {\n    fetchResults();\n  }, [query, session]);\n\n  return { results, loading, error, hasMore, loadMore };\n}\n```",
        "testStrategy": "1. Create unit tests for the caching system:\n```typescript\n// __tests__/cache.test.ts\nimport apiCache from '../lib/cache';\n\ndescribe('Memory Cache', () => {\n  beforeEach(() => {\n    apiCache.invalidateAll();\n  });\n\n  test('should store and retrieve data', () => {\n    const testData = { id: 1, name: 'Test' };\n    apiCache.set('test-key', testData);\n    expect(apiCache.get('test-key')).toEqual(testData);\n  });\n\n  test('should return null for non-existent keys', () => {\n    expect(apiCache.get('non-existent')).toBeNull();\n  });\n\n  test('should expire data after TTL', async () => {\n    // Create a test cache with short TTL for testing\n    const testCache = new MemoryCache(0.01); // 0.01 minutes = 600ms\n    testCache.set('test-key', 'test-data');\n    \n    // Data should be available immediately\n    expect(testCache.get('test-key')).toBe('test-data');\n    \n    // Wait for TTL to expire\n    await new Promise(resolve => setTimeout(resolve, 700));\n    \n    // Data should be expired\n    expect(testCache.get('test-key')).toBeNull();\n  });\n\n  test('should invalidate specific keys', () => {\n    apiCache.set('key1', 'value1');\n    apiCache.set('key2', 'value2');\n    \n    apiCache.invalidate('key1');\n    \n    expect(apiCache.get('key1')).toBeNull();\n    expect(apiCache.get('key2')).toBe('value2');\n  });\n});\n```\n\n2. Test API integration with caching:\n```typescript\n// __tests__/youtube-cache.test.ts\nimport { getChannels, searchVideos } from '../lib/youtube';\nimport apiCache from '../lib/cache';\nimport { mockSession } from '../test/mocks';\n\n// Mock the YouTube API client\njest.mock('googleapis', () => ({\n  google: {\n    auth: {\n      OAuth2: jest.fn().mockImplementation(() => ({\n        setCredentials: jest.fn()\n      }))\n    },\n    youtube: jest.fn().mockImplementation(() => ({\n      channels: {\n        list: jest.fn().mockResolvedValue({\n          data: { items: [{ id: 'channel1' }] }\n        })\n      },\n      search: {\n        list: jest.fn().mockResolvedValue({\n          data: { \n            items: [{ id: 'video1' }],\n            nextPageToken: 'token123'\n          }\n        })\n      }\n    }))\n  }\n}));\n\ndescribe('YouTube API with caching', () => {\n  beforeEach(() => {\n    apiCache.invalidateAll();\n    jest.clearAllMocks();\n  });\n\n  test('should cache channel data', async () => {\n    // First call should hit the API\n    const result1 = await getChannels(mockSession);\n    \n    // Second call should use cache\n    const result2 = await getChannels(mockSession);\n    \n    expect(google.youtube().channels.list).toHaveBeenCalledTimes(1);\n    expect(result1).toEqual(result2);\n  });\n\n  test('should cache search results with pagination tokens', async () => {\n    // First search\n    const result1 = await searchVideos(mockSession, 'test query');\n    \n    // Same search again\n    const result2 = await searchVideos(mockSession, 'test query');\n    \n    // Search with page token\n    const result3 = await searchVideos(mockSession, 'test query', 'token123');\n    \n    // Same search with page token again\n    const result4 = await searchVideos(mockSession, 'test query', 'token123');\n    \n    expect(google.youtube().search.list).toHaveBeenCalledTimes(2); // Only 2 API calls\n    expect(result1).toEqual(result2);\n    expect(result3).toEqual(result4);\n  });\n});\n```\n\n3. Performance testing:\n   - Create a benchmark script to measure API response times with and without caching\n   - Test with a high volume of requests to verify cache effectiveness\n   - Monitor memory usage to ensure the cache doesn't grow too large\n\n4. Integration testing with infinite scroll:\n   - Test the infinite scroll functionality with the caching system\n   - Verify that scrolling triggers new API calls only when needed\n   - Confirm that cached results appear instantly when available\n\n5. Manual testing:\n   - Use browser developer tools to monitor network requests\n   - Verify that repeated requests for the same data don't trigger API calls\n   - Test cache expiration by waiting 5+ minutes and confirming new API calls are made\n   - Check that the application works correctly when offline if cached data is available",
        "status": "done",
        "dependencies": [
          4,
          13
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Data Management System",
        "description": "Develop a comprehensive data management system that allows users to effectively manage stored YouTube channel and video data, including deletion, backup/restore, and statistics features.",
        "details": "1. Create a new data management page or tab:\n   - Option 1: Add a \"Data Management\" tab to the existing `/analytics` page\n   - Option 2: Create a dedicated `/data-management` route\n\n2. Implement manual data deletion functionality:\n```typescript\n// app/data-management/actions.ts\n'use server'\n\nimport prisma from '@/lib/prisma';\n\nexport async function deleteChannel(channelId: string) {\n  try {\n    // Delete all videos associated with the channel first\n    await prisma.video.deleteMany({\n      where: { channelId }\n    });\n    \n    // Then delete the channel\n    await prisma.channel.delete({\n      where: { id: channelId }\n    });\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Error deleting channel:', error);\n    return { success: false, error: 'Failed to delete channel' };\n  }\n}\n\nexport async function deleteVideo(videoId: string) {\n  try {\n    await prisma.video.delete({\n      where: { id: videoId }\n    });\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Error deleting video:', error);\n    return { success: false, error: 'Failed to delete video' };\n  }\n}\n\nexport async function bulkDeleteItems(type: 'channels' | 'videos', ids: string[]) {\n  try {\n    if (type === 'channels') {\n      // Delete all videos for these channels first\n      await prisma.video.deleteMany({\n        where: { channelId: { in: ids } }\n      });\n      \n      // Then delete the channels\n      await prisma.channel.deleteMany({\n        where: { id: { in: ids } }\n      });\n    } else {\n      await prisma.video.deleteMany({\n        where: { id: { in: ids } }\n      });\n    }\n    \n    return { success: true };\n  } catch (error) {\n    console.error(`Error bulk deleting ${type}:`, error);\n    return { success: false, error: `Failed to delete ${type}` };\n  }\n}\n```\n\n3. Implement automatic data cleanup settings:\n```typescript\n// app/data-management/settings/actions.ts\n'use server'\n\nimport prisma from '@/lib/prisma';\n\nexport async function saveCleanupSettings(userId: string, settings: {\n  enabled: boolean;\n  retentionDays: number;\n  applyToChannels: boolean;\n  applyToVideos: boolean;\n}) {\n  try {\n    await prisma.user.update({\n      where: { id: userId },\n      data: {\n        dataRetentionSettings: settings\n      }\n    });\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Error saving cleanup settings:', error);\n    return { success: false, error: 'Failed to save settings' };\n  }\n}\n\nexport async function runManualCleanup(userId: string, olderThanDays: number) {\n  try {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n    \n    // Delete videos older than cutoff date\n    await prisma.video.deleteMany({\n      where: {\n        user: { id: userId },\n        createdAt: { lt: cutoffDate }\n      }\n    });\n    \n    // Optionally delete channels with no videos\n    await prisma.channel.deleteMany({\n      where: {\n        user: { id: userId },\n        createdAt: { lt: cutoffDate },\n        videos: { none: {} }\n      }\n    });\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Error running manual cleanup:', error);\n    return { success: false, error: 'Failed to run cleanup' };\n  }\n}\n```\n\n4. Create data export/import functionality:\n```typescript\n// app/data-management/export/actions.ts\n'use server'\n\nimport prisma from '@/lib/prisma';\nimport { getServerSession } from 'next-auth';\n\nexport async function exportUserData(userId: string, format: 'json' | 'csv') {\n  try {\n    // Fetch user's channels with their videos\n    const userData = await prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        channels: {\n          include: {\n            videos: true\n          }\n        }\n      }\n    });\n    \n    if (format === 'json') {\n      return { \n        success: true, \n        data: JSON.stringify(userData, null, 2),\n        contentType: 'application/json'\n      };\n    } else {\n      // Convert to CSV format (implementation details omitted)\n      const csvData = convertToCSV(userData);\n      return { \n        success: true, \n        data: csvData,\n        contentType: 'text/csv'\n      };\n    }\n  } catch (error) {\n    console.error('Error exporting data:', error);\n    return { success: false, error: 'Failed to export data' };\n  }\n}\n\nexport async function importUserData(userId: string, data: string, format: 'json' | 'csv') {\n  try {\n    let parsedData;\n    \n    if (format === 'json') {\n      parsedData = JSON.parse(data);\n    } else {\n      // Parse CSV data (implementation details omitted)\n      parsedData = parseCSV(data);\n    }\n    \n    // Process and validate the imported data\n    // Then save to database (implementation details omitted)\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Error importing data:', error);\n    return { success: false, error: 'Failed to import data' };\n  }\n}\n```\n\n5. Implement data statistics component:\n```typescript\n// app/data-management/stats/page.tsx\nimport prisma from '@/lib/prisma';\nimport { getServerSession } from 'next-auth';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { BarChart, PieChart } from '@/components/charts';\n\nexport default async function DataStatsPage() {\n  const session = await getServerSession();\n  \n  if (!session?.user?.email) {\n    return <div>Not authenticated</div>;\n  }\n  \n  // Get user data statistics\n  const user = await prisma.user.findUnique({\n    where: { email: session.user.email },\n    include: {\n      _count: {\n        select: {\n          channels: true,\n          videos: true\n        }\n      }\n    }\n  });\n  \n  // Get data size statistics (implementation details omitted)\n  const dataSize = await calculateDataSize(user.id);\n  \n  // Get data by date (implementation details omitted)\n  const dataByDate = await getDataByDate(user.id);\n  \n  return (\n    <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\n      <Card>\n        <CardHeader>\n          <CardTitle>Data Summary</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <p>Channels: {user._count.channels}</p>\n          <p>Videos: {user._count.videos}</p>\n          <p>Total Storage: {dataSize.total}</p>\n        </CardContent>\n      </Card>\n      \n      <Card className=\"md:col-span-2\">\n        <CardHeader>\n          <CardTitle>Data by Date</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <BarChart data={dataByDate} />\n        </CardContent>\n      </Card>\n      \n      {/* Additional statistics cards */}\n    </div>\n  );\n}\n```\n\n6. Create UI components for data management:\n```typescript\n// app/data-management/page.tsx\n'use client'\n\nimport { useState } from 'react';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Button } from '@/components/ui/button';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { DataTable } from '@/components/data-table';\nimport { deleteChannel, deleteVideo, bulkDeleteItems } from './actions';\nimport { toast } from '@/components/ui/use-toast';\n\nexport default function DataManagementPage({ channels, videos }) {\n  const [selectedChannels, setSelectedChannels] = useState<string[]>([]);\n  const [selectedVideos, setSelectedVideos] = useState<string[]>([]);\n  \n  const handleDeleteSelected = async (type: 'channels' | 'videos') => {\n    const ids = type === 'channels' ? selectedChannels : selectedVideos;\n    if (ids.length === 0) return;\n    \n    const result = await bulkDeleteItems(type, ids);\n    if (result.success) {\n      toast({\n        title: 'Success',\n        description: `Selected ${type} have been deleted.`,\n      });\n      // Reset selections and refresh data\n      if (type === 'channels') setSelectedChannels([]);\n      else setSelectedVideos([]);\n    } else {\n      toast({\n        title: 'Error',\n        description: result.error,\n        variant: 'destructive',\n      });\n    }\n  };\n  \n  return (\n    <div className=\"container mx-auto py-6\">\n      <h1 className=\"text-2xl font-bold mb-6\">Data Management</h1>\n      \n      <Tabs defaultValue=\"channels\">\n        <TabsList>\n          <TabsTrigger value=\"channels\">Channels</TabsTrigger>\n          <TabsTrigger value=\"videos\">Videos</TabsTrigger>\n          <TabsTrigger value=\"settings\">Cleanup Settings</TabsTrigger>\n          <TabsTrigger value=\"backup\">Backup & Restore</TabsTrigger>\n          <TabsTrigger value=\"stats\">Statistics</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"channels\">\n          {selectedChannels.length > 0 && (\n            <div className=\"mb-4 flex items-center justify-between\">\n              <p>{selectedChannels.length} channels selected</p>\n              <Button \n                variant=\"destructive\" \n                onClick={() => handleDeleteSelected('channels')}\n              >\n                Delete Selected\n              </Button>\n            </div>\n          )}\n          \n          <DataTable \n            data={channels}\n            columns={[/* channel columns with checkbox selection */]}\n            onSelectionChange={setSelectedChannels}\n          />\n        </TabsContent>\n        \n        <TabsContent value=\"videos\">\n          {/* Similar implementation for videos tab */}\n        </TabsContent>\n        \n        <TabsContent value=\"settings\">\n          {/* Cleanup settings form */}\n        </TabsContent>\n        \n        <TabsContent value=\"backup\">\n          {/* Backup and restore UI */}\n        </TabsContent>\n        \n        <TabsContent value=\"stats\">\n          {/* Stats will be rendered from stats/page.tsx */}\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n```\n\n7. Set up scheduled cleanup job (optional server component):\n```typescript\n// lib/scheduled-cleanup.ts\nimport prisma from './prisma';\n\nexport async function runScheduledCleanup() {\n  try {\n    // Find all users with cleanup enabled\n    const users = await prisma.user.findMany({\n      where: {\n        dataRetentionSettings: {\n          path: ['enabled'],\n          equals: true\n        }\n      }\n    });\n    \n    for (const user of users) {\n      const settings = user.dataRetentionSettings;\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - settings.retentionDays);\n      \n      // Delete old videos if enabled\n      if (settings.applyToVideos) {\n        await prisma.video.deleteMany({\n          where: {\n            userId: user.id,\n            createdAt: { lt: cutoffDate }\n          }\n        });\n      }\n      \n      // Delete old channels if enabled\n      if (settings.applyToChannels) {\n        await prisma.channel.deleteMany({\n          where: {\n            userId: user.id,\n            createdAt: { lt: cutoffDate },\n            // Optionally only delete channels with no videos\n            videos: { none: {} }\n          }\n        });\n      }\n    }\n    \n    console.log('Scheduled cleanup completed successfully');\n  } catch (error) {\n    console.error('Error in scheduled cleanup:', error);\n  }\n}\n```\n\n8. Update database schema to support data management features:\n```prisma\n// prisma/schema.prisma (additions)\nmodel User {\n  // ... existing fields\n  dataRetentionSettings Json? // Stores cleanup configuration\n}\n```",
        "testStrategy": "1. Test manual data deletion functionality:\n   - Test deleting a single channel and verify all associated videos are also deleted\n   - Test deleting a single video and verify it's removed from the database\n   - Test bulk deletion with multiple selected channels/videos\n   - Verify proper error handling when deletion fails\n   - Test UI feedback (loading states, success/error messages)\n\n2. Test automatic cleanup settings:\n   - Verify settings are saved correctly to the user profile\n   - Test the manual cleanup function with different retention periods\n   - Verify old data is correctly identified and removed\n   - Test edge cases (e.g., all data qualifying for deletion, no data qualifying)\n   - If implemented, test the scheduled cleanup job with mock data\n\n3. Test data export/import functionality:\n   - Test exporting data in JSON format and verify the structure is correct\n   - Test exporting data in CSV format and verify the structure is correct\n   - Test importing valid JSON data and verify it's correctly saved to the database\n   - Test importing valid CSV data and verify it's correctly saved to the database\n   - Test error handling for invalid import data formats\n   - Test handling of duplicate data during import\n\n4. Test data statistics component:\n   - Verify accurate count of channels and videos\n   - Test calculation of storage usage\n   - Verify date-based statistics are correctly calculated and displayed\n   - Test with various data volumes (empty, small, large datasets)\n   - Verify charts render correctly with different data patterns\n\n5. Test UI components:\n   - Verify all tabs render correctly and display appropriate content\n   - Test checkbox selection for multiple items\n   - Test responsive design on different screen sizes\n   - Verify proper loading states during data operations\n   - Test accessibility of all UI components\n\n6. Integration testing:\n   - Test the complete workflow from data creation to management\n   - Verify deleted data doesn't appear in other parts of the application\n   - Test the impact of data management operations on analytics features\n   - Verify performance with large datasets\n\n7. Security testing:\n   - Verify users can only manage their own data\n   - Test authorization checks on all data management endpoints\n   - Verify data export doesn't include sensitive information",
        "status": "pending",
        "dependencies": [
          6,
          8,
          10
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "ìˆ˜ë™ ë°ì´í„° ì‚­ì œ ê¸°ëŠ¥ êµ¬í˜„",
            "description": "ê°œë³„ ë° ì„ íƒì  ì‚­ì œë¥¼ ìœ„í•œ UIì™€ API ê°œë°œ",
            "dependencies": [],
            "details": "ì‚¬ìš©ìê°€ íŠ¹ì • ë°ì´í„°ë¥¼ ì„ íƒí•˜ì—¬ ì‚­ì œí•  ìˆ˜ ìˆëŠ” ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„ ë° êµ¬í˜„. RESTful API ì—”ë“œí¬ì¸íŠ¸ ìƒì„± ë° í”„ë¡ íŠ¸ì—”ë“œì™€ ì—°ë™.\n<info added on 2025-06-26T09:04:05.831Z>\në°ì´í„° ë¡œë”© ë¬¸ì œ í•´ê²°:\n- ë¬¸ì œ ì›ì¸: API ì‘ë‹µ êµ¬ì¡° ë¶ˆì¼ì¹˜ ë°œê²¬\n- analytics APIëŠ” `data` ê°ì²´ ì•ˆì— ë°°ì—´ì„ ë°˜í™˜í•˜ì§€ë§Œ, ì»´í¬ë„ŒíŠ¸ì—ì„œëŠ” ì§ì ‘ ë°°ì—´ì— ì ‘ê·¼í•˜ë ¤ í–ˆìŒ\n- ìˆ˜ì •: channelsData.data?.channelsì™€ videosData.data?.videosë¡œ ë³€ê²½\n- ë””ë²„ê¹…ì„ ìœ„í•œ console.log ì¶”ê°€\n- ê°œë°œ ì„œë²„ ì¬ì‹œì‘ ì™„ë£Œ\n</info added on 2025-06-26T09:04:05.831Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "ìë™ ì •ë¦¬ ì˜µì…˜ ê°œë°œ",
            "description": "ìŠ¤ì¼€ì¤„ë§ ê¸°ë°˜ ë°ì´í„° ìë™ ì‚­ì œ ì‹œìŠ¤í…œ êµ¬ì¶•",
            "dependencies": [
              1
            ],
            "details": "ì‚¬ìš©ì ì •ì˜ ê·œì¹™ì— ë”°ë¥¸ ìë™ ì‚­ì œ ë¡œì§ êµ¬í˜„. í¬ë¡  ì‘ì—… ì„¤ì • ë° ì‚­ì œ í”„ë¡œì„¸ìŠ¤ ìë™í™”.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "ë°ì´í„° ë°±ì—…/ë³µì› ì‹œìŠ¤í…œ êµ¬í˜„",
            "description": "JSON/CSV í˜•ì‹ì˜ ë°ì´í„° ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸° ê¸°ëŠ¥ ê°œë°œ",
            "dependencies": [
              1
            ],
            "details": "ë°ì´í„° ì¶”ì¶œ ë° ë³€í™˜ ë¡œì§ êµ¬í˜„. íŒŒì¼ ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ ê°œë°œ ë° ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ë°ì´í„° ê´€ë¦¬ ëŒ€ì‹œë³´ë“œ ìƒì„±",
            "description": "í†µê³„ ë° ê´€ë¦¬ ì¸í„°í˜ì´ìŠ¤ ê°œë°œ",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "ë°ì´í„° ì‹œê°í™” ì»´í¬ë„ŒíŠ¸ êµ¬í˜„. ì‚¬ìš©ì ì¹œí™”ì  ê´€ë¦¬ ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„ ë° ê°œë°œ. ì‹¤ì‹œê°„ í†µê³„ ì—…ë°ì´íŠ¸ ê¸°ëŠ¥ í†µí•©.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-25T04:36:41.298Z",
      "updated": "2025-06-26T08:56:50.174Z",
      "description": "Tasks for mvp context"
    }
  }
}